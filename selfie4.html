<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Selfie Mode 4 - Dynamic Modes</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: monospace;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        /* Canvas Layers - Stacked with different purposes */
        #bg_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            transition: opacity 0.6s ease-in-out;
        }

        #camera_feed_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            object-fit: cover;
            transition: opacity 0.6s ease-in-out;
        }

        #three_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            transition: opacity 0.6s ease-in-out;
        }

        .output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            transition: opacity 0.6s ease-in-out;
        }

        .input_video {
            display: none;
        }

        #status {
            position: absolute;
            color: cyan;
            z-index: 4;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 4px;
            pointer-events: none;
        }

        /* Back button */
        #back_btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 5;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 1px solid white;
            padding: 8px 16px;
            border-radius: 20px;
            text-decoration: none;
            font-family: sans-serif;
            text-transform: uppercase;
            font-size: 12px;
            backdrop-filter: blur(4px);
        }

        /* Mode Toggle Button */
        #mode_toggle {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(235, 41, 45, 0.3));
            border: 3px solid rgba(255, 255, 255, 0.6);
            color: white;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
        }

        #mode_toggle:hover {
            transform: translateX(-50%) scale(1.1);
            box-shadow: 0 6px 30px rgba(0, 255, 255, 0.6);
        }

        #mode_toggle:active {
            transform: translateX(-50%) scale(0.95);
        }

        #mode_toggle .mode-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
            margin-top: 2px;
        }

        /* Animation for mode switching */
        @keyframes pulse {

            0%,
            100% {
                transform: translateX(-50%) scale(1);
            }

            50% {
                transform: translateX(-50%) scale(1.15);
            }
        }

        .mode-switching {
            animation: pulse 0.4s ease-in-out;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"
        crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="container">
        <div id="status">Loading System...</div>
        <a href="index.html" id="back_btn">Back</a>

        <!-- Canvas Layers -->
        <canvas id="bg_canvas"></canvas>
        <canvas id="camera_feed_canvas"></canvas>
        <canvas id="three_canvas"></canvas>
        <canvas class="output_canvas"></canvas>

        <!-- Mode Toggle Button -->
        <button id="mode_toggle">
            <span id="mode_number">1</span>
            <span class="mode-label">Mode</span>
        </button>
    </div>
    <video class="input_video"></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        // =========================================================
        //  === STATE MANAGEMENT ===
        // =========================================================

        let currentMode = 1; // Start with Mode 1
        let isTransitioning = false;

        // =========================================================
        //  === DOM ELEMENTS ===
        // =========================================================

        const bgCanvas = document.getElementById('bg_canvas');
        const bgCtx = bgCanvas.getContext('2d');

        const cameraFeedCanvas = document.getElementById('camera_feed_canvas');
        const cameraFeedCtx = cameraFeedCanvas.getContext('2d');

        const threeCanvas = document.getElementById('three_canvas');

        const outputCanvas = document.querySelector('.output_canvas');
        const outputCtx = outputCanvas.getContext('2d');

        const statusText = document.getElementById('status');
        const videoElement = document.querySelector('.input_video');
        const modeToggleBtn = document.getElementById('mode_toggle');
        const modeNumberSpan = document.getElementById('mode_number');

        let width = window.innerWidth;
        let height = window.innerHeight;

        // =========================================================
        //  === CONFIGURATION ===
        // =========================================================

        // Mode 1 Settings
        const MODEL_WIDTH_PCT = 0.9;
        const ROTATION_FIX_Y = 0.0;
        const VERTICAL_OFFSET = 0.0;
        const HORIZONTAL_OFFSET = 0.0;

        // Segmentation Quality (Modes 1 & 2)
        const MASK_BLUR_PX = 3;
        const MASK_SMOOTHING_ALPHA = 0.35;

        // Mode 2 Settings
        const MODEL_SCALE_BASE = 1.0;

        // Mode 3 Settings
        const BLOOM_THRESHOLD = 1.5;
        const BLOOM_STRENGTH = 2.0;
        const BLOOM_RADIUS = 0.5;
        const NEON_COLOR = 0xEB292D;
        const NEON_INTENSITY_SCALAR = 10.0;

        // =========================================================
        //  === THREE.JS SCENE SETUP ===
        // =========================================================

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
        camera.position.set(0, 0, 10);

        const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        // =========================================================
        //  === MODE 1 ELEMENTS ===
        // =========================================================

        const textureLoader = new THREE.TextureLoader();

        // Background Plane for Mode 1
        const bgGeometry = new THREE.PlaneGeometry(40, 40, 128, 128);
        const bgDiffuse = textureLoader.load('./bg_diffuse.png');
        const bgDisplacement = textureLoader.load('./bg_displacement.png');
        const bgMaterial = new THREE.MeshStandardMaterial({
            map: bgDiffuse,
            displacementMap: bgDisplacement,
            displacementScale: 2.0,
            color: 0xffffff,
            roughness: 0.4,
            metalness: 0.1
        });
        const bgPlane = new THREE.Mesh(bgGeometry, bgMaterial);
        bgPlane.position.z = -5;
        bgPlane.visible = false; // Start hidden
        scene.add(bgPlane);

        // Neon Material for Mode 1
        const neonMaterial = new THREE.MeshBasicMaterial({ color: 0xEB292D, wireframe: false });

        let mode1Model = null;
        let mode1PointLight = null;

        // =========================================================
        //  === MODE 2 ELEMENTS ===
        // =========================================================

        let mode2Model = null;
        let mode2Mixer = null;

        // Lighting for Mode 2
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        ambientLight.visible = false;
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(2, 5, 5);
        dirLight.visible = false;
        scene.add(dirLight);

        // Environment for Mode 2
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        let mode2Environment = null;

        // =========================================================
        //  === MODE 3 ELEMENTS ===
        // =========================================================

        const videoTexture = new THREE.VideoTexture(videoElement);
        videoTexture.colorSpace = THREE.SRGBColorSpace;

        const videoGeometry = new THREE.PlaneGeometry(1, 1);
        const videoMaterial = new THREE.MeshStandardMaterial({
            map: videoTexture,
            side: THREE.DoubleSide,
            roughness: 1,
            metalness: 0,
            color: 0xffffff
        });
        const videoPlane = new THREE.Mesh(videoGeometry, videoMaterial);
        videoPlane.position.z = -10;
        videoPlane.visible = false;
        scene.add(videoPlane);

        const mode3AmbientLight = new THREE.AmbientLight(0xffffff, 1.2);
        mode3AmbientLight.visible = false;
        scene.add(mode3AmbientLight);

        let mode3Model = null;
        let mode3PointLight = null;

        // HDR Material for Mode 3 Neon
        const mode3NeonMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color(NEON_COLOR).multiplyScalar(NEON_INTENSITY_SCALAR)
        });

        // =========================================================
        //  === POST-PROCESSING (BLOOM) ===
        // =========================================================

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // =========================================================
        //  === TEMPORAL SMOOTHING (FOR SEGMENTATION) ===
        // =========================================================

        let offscreenCanvas = null;
        let offscreenCtx = null;
        let previousMaskData = null;
        let currentMaskData = null;

        function initTemporalSmoothing(w, h) {
            offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = w;
            offscreenCanvas.height = h;
            offscreenCtx = offscreenCanvas.getContext('2d');
            previousMaskData = null;
            currentMaskData = null;
        }

        // =========================================================
        //  === LOAD MODELS ===
        // =========================================================

        const loader = new GLTFLoader();

        // Load Mode 1 Model (model.gltf - Neon Sign)
        loader.load('./model.gltf', function (gltf) {
            mode1Model = gltf.scene;

            mode1Model.traverse((child) => {
                if (child.isMesh) child.material = neonMaterial;
            });

            mode1PointLight = new THREE.PointLight(0xEB292D, 2, 20);
            mode1PointLight.position.set(0, 5, 0);
            mode1Model.add(mode1PointLight);

            mode1Model.visible = false;
            scene.add(mode1Model);

            fitMode1ModelToCamera();
            statusText.innerText = "System Active - Mode 1";
        });

        // Load Mode 2 Model (back_model.glb)
        loader.load('./back_model.glb', function (gltf) {
            mode2Model = gltf.scene;

            const box = new THREE.Box3().setFromObject(mode2Model);
            const center = box.getCenter(new THREE.Vector3());
            mode2Model.position.sub(center);
            mode2Model.scale.set(MODEL_SCALE_BASE, MODEL_SCALE_BASE, MODEL_SCALE_BASE);

            mode2Model.visible = false;
            scene.add(mode2Model);

            if (gltf.animations && gltf.animations.length) {
                mode2Mixer = new THREE.AnimationMixer(mode2Model);
                gltf.animations.forEach((clip) => {
                    mode2Mixer.clipAction(clip).play();
                });
            }
        });

        // Load Mode 3 Model (model.gltf - Neon Sign with HDR)
        loader.load('./model.gltf', function (gltf) {
            mode3Model = gltf.scene;

            mode3Model.traverse((child) => {
                if (child.isMesh) child.material = mode3NeonMaterial;
            });

            const box = new THREE.Box3().setFromObject(mode3Model);
            const center = box.getCenter(new THREE.Vector3());
            mode3Model.position.sub(center);

            mode3PointLight = new THREE.PointLight(NEON_COLOR, 100, 50);
            mode3PointLight.position.set(0, 0, 2);
            mode3Model.add(mode3PointLight);

            mode3Model.visible = false;
            scene.add(mode3Model);

            fitMode3ModelToCamera();
        });

        // =========================================================
        //  === MODEL POSITIONING FUNCTIONS ===
        // =========================================================

        function fitMode1ModelToCamera() {
            if (!mode1Model) return;

            mode1Model.rotation.set(0, 0, 0);
            mode1Model.scale.set(1, 1, 1);
            mode1Model.position.set(0, 0, 0);
            mode1Model.updateMatrixWorld(true);

            const dist = camera.position.z;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            const visibleWidth = visibleHeight * camera.aspect;

            const box = new THREE.Box3().setFromObject(mode1Model);
            const size = new THREE.Vector3();
            box.getSize(size);
            const center = new THREE.Vector3();
            box.getCenter(center);

            let scaleFactor = (visibleWidth / size.x) * MODEL_WIDTH_PCT;
            mode1Model.scale.set(scaleFactor, scaleFactor, scaleFactor);

            const scaledMaxZ = box.max.z * scaleFactor;
            mode1Model.position.z = -scaledMaxZ;

            const scaledTopY = box.max.y * scaleFactor;
            const targetTopY = visibleHeight / 2;
            const topPadding = visibleHeight * 0.05;

            mode1Model.position.y = (targetTopY - scaledTopY - topPadding) + VERTICAL_OFFSET;

            const scaledCenterX = center.x * scaleFactor;
            mode1Model.position.x = -scaledCenterX + HORIZONTAL_OFFSET;

            mode1Model.rotation.y = ROTATION_FIX_Y;
        }

        function fitMode3ModelToCamera() {
            if (!mode3Model) return;

            mode3Model.rotation.set(0, 0, 0);
            mode3Model.scale.set(1, 1, 1);
            mode3Model.position.set(0, 0, 0);
            mode3Model.updateMatrixWorld(true);

            const dist = camera.position.z;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
            const visibleWidth = visibleHeight * camera.aspect;

            const box = new THREE.Box3().setFromObject(mode3Model);
            const size = new THREE.Vector3();
            box.getSize(size);
            const center = new THREE.Vector3();
            box.getCenter(center);

            let scaleFactor = (visibleWidth / size.x) * MODEL_WIDTH_PCT;
            mode3Model.scale.set(scaleFactor, scaleFactor, scaleFactor);

            const scaledMaxZ = box.max.z * scaleFactor;
            mode3Model.position.z = -scaledMaxZ;

            const scaledTopY = box.max.y * scaleFactor;
            const targetTopY = visibleHeight / 2;
            const topPadding = visibleHeight * 0.05;

            mode3Model.position.y = (targetTopY - scaledTopY - topPadding) + VERTICAL_OFFSET;

            const scaledCenterX = center.x * scaleFactor;
            mode3Model.position.x = -scaledCenterX + HORIZONTAL_OFFSET;

            mode3Model.rotation.y = ROTATION_FIX_Y;
        }

        function updateVideoPlane() {
            if (videoElement.readyState < videoElement.HAVE_ENOUGH_DATA) return;

            const videoW = videoElement.videoWidth;
            const videoH = videoElement.videoHeight;
            const videoAspect = videoW / videoH;
            const screenAspect = width / height;

            const distance = camera.position.z - videoPlane.position.z;
            const vFOV = THREE.MathUtils.degToRad(camera.fov);
            const visibleHeight = 2 * Math.tan(vFOV / 2) * distance;
            const visibleWidth = visibleHeight * camera.aspect;

            let scaleX, scaleY;

            if (screenAspect > videoAspect) {
                scaleX = visibleWidth;
                scaleY = visibleWidth / videoAspect;
            } else {
                scaleY = visibleHeight;
                scaleX = visibleHeight * videoAspect;
            }

            videoPlane.scale.set(-scaleX, scaleY, 1);
        }

        // =========================================================
        //  === MODE SWITCHING ===
        // =========================================================

        function setMode(newMode) {
            if (isTransitioning || newMode === currentMode) return;

            isTransitioning = true;
            modeToggleBtn.classList.add('mode-switching');

            // Fade out current mode
            fadeOutMode(currentMode, () => {
                currentMode = newMode;
                modeNumberSpan.textContent = currentMode;

                // Fade in new mode
                fadeInMode(currentMode, () => {
                    isTransitioning = false;
                    modeToggleBtn.classList.remove('mode-switching');
                    statusText.innerText = `System Active - Mode ${currentMode}`;
                });
            });
        }

        function fadeOutMode(mode, callback) {
            switch (mode) {
                case 1:
                    bgCanvas.style.opacity = '0';
                    outputCanvas.style.opacity = '0';
                    if (mode1Model) mode1Model.visible = false;
                    if (bgPlane) bgPlane.visible = false;
                    scene.background = null;
                    break;
                case 2:
                    cameraFeedCanvas.style.opacity = '0';
                    outputCanvas.style.opacity = '0';
                    if (mode2Model) mode2Model.visible = false;
                    ambientLight.visible = false;
                    dirLight.visible = false;
                    scene.environment = null;
                    break;
                case 3:
                    threeCanvas.style.opacity = '0';
                    if (mode3Model) mode3Model.visible = false;
                    if (videoPlane) videoPlane.visible = false;
                    mode3AmbientLight.visible = false;
                    break;
            }

            setTimeout(callback, 600); // Match CSS transition duration
        }

        function fadeInMode(mode, callback) {
            switch (mode) {
                case 1:
                    // Mode 1: Neon Sign with Bloom + Segmentation
                    scene.background = new THREE.Color(0x000000);
                    if (bgPlane) bgPlane.visible = true;
                    if (mode1Model) {
                        mode1Model.visible = true;
                        fitMode1ModelToCamera();
                    }
                    bloomPass.threshold = 0;
                    bloomPass.strength = 2.0;
                    bgCanvas.style.opacity = '0'; // Mode 1 doesn't use bg_canvas, uses Three.js background
                    threeCanvas.style.opacity = '1';
                    outputCanvas.style.opacity = '1';
                    cameraFeedCanvas.style.opacity = '0';
                    break;
                case 2:
                    // Mode 2: Clean Camera Feed + 3D Model + Segmented User
                    scene.background = null;
                    if (mode2Model) mode2Model.visible = true;
                    ambientLight.visible = true;
                    dirLight.visible = true;
                    if (!mode2Environment) {
                        mode2Environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
                    }
                    scene.environment = mode2Environment;
                    cameraFeedCanvas.style.opacity = '1';
                    threeCanvas.style.opacity = '1';
                    outputCanvas.style.opacity = '1';
                    bgCanvas.style.opacity = '0';
                    break;
                case 3:
                    // Mode 3: Video Background + Neon Sign with Bloom
                    camera.position.set(0, 0, 10); // Reset camera position for Mode 3
                    scene.background = null;
                    if (videoPlane) {
                        videoPlane.visible = true;
                        updateVideoPlane();
                    }
                    if (mode3Model) {
                        mode3Model.visible = true;
                        fitMode3ModelToCamera();
                    }
                    mode3AmbientLight.visible = true;
                    bloomPass.threshold = BLOOM_THRESHOLD;
                    bloomPass.strength = BLOOM_STRENGTH;
                    threeCanvas.style.opacity = '1';
                    bgCanvas.style.opacity = '0';
                    cameraFeedCanvas.style.opacity = '0';
                    outputCanvas.style.opacity = '0';
                    break;
            }

            setTimeout(callback, 600);
        }

        // =========================================================
        //  === MODE TOGGLE BUTTON ===
        // =========================================================

        modeToggleBtn.addEventListener('click', () => {
            const nextMode = (currentMode % 3) + 1;
            setMode(nextMode);
        });

        // =========================================================
        //  === MEDIAPIPE RESULTS ===
        // =========================================================

        function onResults(results) {
            // Skip segmentation processing in Mode 3
            if (currentMode === 3) return;

            const img = results.image;
            const imgRatio = img.width / img.height;

            let drawWidth, drawHeight, x, y;

            if (currentMode === 1) {
                // Mode 1: Height-based cover for output canvas
                drawHeight = outputCanvas.height;
                drawWidth = drawHeight * imgRatio;
                x = (outputCanvas.width - drawWidth) / 2;
                y = 0;
            } else {
                // Mode 2: Cover logic for both canvases
                const canvasRatio = outputCanvas.width / outputCanvas.height;
                if (imgRatio > canvasRatio) {
                    drawHeight = outputCanvas.height;
                    drawWidth = drawHeight * imgRatio;
                } else {
                    drawWidth = outputCanvas.width;
                    drawHeight = drawWidth / imgRatio;
                }
                x = (outputCanvas.width - drawWidth) / 2;
                y = (outputCanvas.height - drawHeight) / 2;
            }

            // ===== MODE 2: Clean Camera Feed =====
            if (currentMode === 2) {
                cameraFeedCtx.save();
                cameraFeedCtx.clearRect(0, 0, cameraFeedCanvas.width, cameraFeedCanvas.height);
                cameraFeedCtx.translate(cameraFeedCanvas.width, 0);
                cameraFeedCtx.scale(-1, 1);
                cameraFeedCtx.drawImage(results.image, x, y, drawWidth, drawHeight);
                cameraFeedCtx.restore();
            }

            // ===== SEGMENTED USER (Modes 1 & 2) =====
            outputCtx.save();
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            outputCtx.translate(outputCanvas.width, 0);
            outputCtx.scale(-1, 1);

            // Temporal Smoothing
            if (!offscreenCanvas) initTemporalSmoothing(drawWidth, drawHeight);
            if (offscreenCanvas.width !== drawWidth || offscreenCanvas.height !== drawHeight) {
                offscreenCanvas.width = drawWidth;
                offscreenCanvas.height = drawHeight;
                previousMaskData = null;
            }

            offscreenCtx.clearRect(0, 0, drawWidth, drawHeight);
            offscreenCtx.drawImage(results.segmentationMask, 0, 0, drawWidth, drawHeight);
            currentMaskData = offscreenCtx.getImageData(0, 0, drawWidth, drawHeight);

            if (previousMaskData && previousMaskData.width === currentMaskData.width) {
                const current = currentMaskData.data;
                const previous = previousMaskData.data;
                for (let i = 0; i < current.length; i += 4) {
                    const alpha = MASK_SMOOTHING_ALPHA;
                    current[i] = alpha * current[i] + (1 - alpha) * previous[i];
                    current[i + 1] = alpha * current[i + 1] + (1 - alpha) * previous[i + 1];
                    current[i + 2] = alpha * current[i + 2] + (1 - alpha) * previous[i + 2];
                    current[i + 3] = alpha * current[i + 3] + (1 - alpha) * previous[i + 3];
                }
            }

            previousMaskData = new ImageData(new Uint8ClampedArray(currentMaskData.data), drawWidth, drawHeight);
            offscreenCtx.putImageData(currentMaskData, 0, 0);

            // Draw with blur
            outputCtx.filter = `blur(${MASK_BLUR_PX}px)`;
            outputCtx.drawImage(offscreenCanvas, x, y, drawWidth, drawHeight);
            outputCtx.filter = 'none';

            // Composite
            outputCtx.globalCompositeOperation = 'source-in';
            outputCtx.drawImage(results.image, x, y, drawWidth, drawHeight);
            outputCtx.globalCompositeOperation = 'source-over';

            outputCtx.restore();
        }

        // =========================================================
        //  === MEDIAPIPE INIT ===
        // =========================================================

        const selfieSegmentation = new SelfieSegmentation({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
        });

        selfieSegmentation.setOptions({
            modelSelection: 1,
            selfieMode: true
        });

        selfieSegmentation.onResults(onResults);

        const mpCamera = new Camera(videoElement, {
            onFrame: async () => { await selfieSegmentation.send({ image: videoElement }); },
            width: 1280,
            height: 720
        });
        mpCamera.start();

        // =========================================================
        //  === RESIZE HANDLER ===
        // =========================================================

        function handleResize() {
            width = window.innerWidth;
            height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            composer.setSize(width, height);
            bloomPass.resolution.set(width, height);

            bgCanvas.width = width;
            bgCanvas.height = height;
            cameraFeedCanvas.width = width;
            cameraFeedCanvas.height = height;
            outputCanvas.width = width;
            outputCanvas.height = height;

            initTemporalSmoothing(width, height);

            fitMode1ModelToCamera();
            fitMode3ModelToCamera();
            updateVideoPlane();
        }

        window.addEventListener('resize', handleResize);
        videoElement.addEventListener('loadedmetadata', updateVideoPlane);
        handleResize();

        // =========================================================
        //  === ANIMATION LOOP ===
        // =========================================================

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.005;

            if (currentMode === 1 && mode1Model) {
                // Mode 1: Neon Flicker
                const flicker = Math.random() > 0.9 ? Math.random() * 0.5 : 0;
                const pulse = Math.sin(time * 2) * 0.1;

                bloomPass.strength = 2.0 + pulse + flicker;

                if (mode1PointLight) {
                    mode1PointLight.intensity = 2.0 + (pulse * 2) + (flicker * 3);
                }
            }

            if (currentMode === 2 && mode2Model) {
                // Mode 2: Breathing Animation
                const scale = 1.15 + Math.sin(time * 0.2) * 0.05;
                mode2Model.scale.set(scale, scale, scale);

                mode2Model.rotation.y = Math.sin(time * 0.1) * 0.2;
                mode2Model.rotation.x = Math.cos(time * 0.06) * 0.1;

                if (mode2Mixer) mode2Mixer.update(0.016);
            }

            if (currentMode === 3 && mode3Model) {
                // Mode 3: Neon Flicker
                const flicker = Math.random() > 0.9 ? Math.random() * 0.5 : 0;
                const pulse = Math.sin(time * 2) * 0.1;

                bloomPass.strength = 2.0 + pulse + flicker;

                if (mode3PointLight) {
                    mode3PointLight.intensity = 100.0 + (pulse * 20) + (flicker * 30);
                }

                updateVideoPlane();
            }

            composer.render();
        }
        animate();

        // =========================================================
        //  === INITIALIZE MODE 1 ===
        // =========================================================

        // Start with Mode 1 visible
        setTimeout(() => {
            fadeInMode(1, () => {
                statusText.innerText = "System Active - Mode 1";
            });
        }, 500);

    </script>
</body>

</html>